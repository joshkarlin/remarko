use colored::*;
use ssh2::Session;

use crate::constants::{COLLECTION, DIR, DOCUMENT};
use crate::nodes::{Directory, DirectoryNode, File, Hash, Metadata, Node, SystemDirectory};
use crate::ssh_utils::read_remote_metadata;

/// Parse the output of `ls` to get the file and directory hashes.
/// The output of `ls` is a single string, so it needs to be trimmed
/// and split on newlines. The file extensions are then removed to
/// obtain the hashes generated by remarkable.
pub fn get_hashes_from_ls_output(ls_output: &str) -> Vec<&str> {
    let all_files: Vec<&str> = ls_output.trim().split("\n").collect();
    let mut file_hashes: Vec<&str> = Vec::new();
    for file in all_files {
        let file_hash = file.split(".").collect::<Vec<&str>>()[0];
        file_hashes.push(file_hash);
    }

    file_hashes.dedup();

    return file_hashes;
}

pub fn build_tree(hashes: Vec<&str>, sess: &mut Session) -> (Directory, Directory) {
    let mut directories = Vec::new();
    let mut files = Vec::new();

    // create nodes for all files and directories
    for hash in hashes {
        let metadata_file_name = format!("{}/{}.metadata", DIR, hash);
        let metadata = read_remote_metadata(sess, &metadata_file_name);

        if metadata.type_ == DOCUMENT {
            let file = File::new(Hash::new(hash.to_string()), metadata);
            files.push(file);
        } else if metadata.type_ == COLLECTION {
            let directory = Directory::new(Hash::new(hash.to_string()), metadata, None, None);
            directories.push(directory);
        } else {
            println!("Unknown type: {}", metadata.type_);
        };
    }

    // manually create root and trash directories
    let root_metadata = Metadata::new(
        "home".to_string(),
        None,
        "420".to_string(),
        "directory".to_string(),
    );
    let trash_metadata = Metadata::new(
        "trash".to_string(),
        None,
        "420".to_string(),
        "directory".to_string(),
    );

    let root_directory = Directory::new(Hash::new("".to_string()), root_metadata, None, None);
    let trash_directory =
        Directory::new(Hash::new("trash".to_string()), trash_metadata, None, None);

    // add root_directory at start of directories
    directories.insert(0, root_directory);
    // add trash_directory after root_directory
    directories.insert(1, trash_directory);

    // match files with parent directories
    for file in files {
        let parent_name = file.get_parent().unwrap();
        // TODO improve this
        let parent = directories
            .iter_mut()
            .find(|d| d.get_hash().to_string() == parent_name.to_string())
            .unwrap();
        parent.add_file(file);
    }

    // match directories with parent directories
    for directory in directories.clone() {
        // if parent is None, continue, else find parent and add directory
        let parent_name = directory.get_parent();
        if parent_name.is_none() {
            continue;
        }
        // TODO improve this
        let parent = directories
            .iter_mut()
            .find(|d| d.get_hash().to_string() == parent_name.unwrap().to_string())
            .unwrap();
        parent.add_directory(directory.clone());
    }

    return (directories.remove(0), directories.remove(0));
}

pub fn print_tree(node: &dyn Node, depth: usize) {
    // Print the current node with indentation based on the depth
    let indent = " ".repeat(depth * 2);

    // if node is a directory, loop through its child directories
    if let Some(directory_node) = node.as_any().downcast_ref::<SystemDirectory>() {
        println!(
            "{}{}{}",
            indent,
            directory_node.get_visible_name().bold().green(),
            "/".bold().green()
        );
        for directory in directory_node.get_directories() {
            print_tree(directory, depth + 1);
        }
        for file in directory_node.get_files() {
            print_tree(file, depth + 1);
        }
    } else if let Some(directory_node) = node.as_any().downcast_ref::<Directory>() {
        println!(
            "{}{}{}",
            indent,
            directory_node.get_visible_name().bold().green(),
            "/".bold().green()
        );
        for directory in directory_node.get_directories() {
            print_tree(directory, depth + 1);
        }
        for file in directory_node.get_files() {
            print_tree(file, depth + 1);
        }
    } else if let Some(file_node) = node.as_any().downcast_ref::<File>() {
        println!(
            "{}{} {} {}",
            indent,
            file_node.get_last_modified(),
            file_node.get_hash().to_string().bold().purple().on_blue(),
            file_node.get_visible_name().purple()
        );
    }
}
