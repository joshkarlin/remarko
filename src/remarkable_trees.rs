use colored::*;
use ssh2::Session;

use crate::constants::{COLLECTION, DIR, DOCUMENT};
use crate::nodes::{Directory, DirectoryNode, File, Hash, Node, SystemDirectory};
use crate::ssh_utils::read_remote_json_file;

/// Parse the output of `ls` to get the file and directory hashes.
/// The output of `ls` is a single string, so it needs to be trimmed
/// and split on newlines. The file extensions are then removed to
/// obtain the hashes generated by remarkable.
pub fn get_hashes_from_ls_output(ls_output: &str) -> Vec<&str> {
    let all_files: Vec<&str> = ls_output.trim().split("\n").collect();
    let mut file_hashes: Vec<&str> = Vec::new();
    for file in all_files {
        let file_hash = file.split(".").collect::<Vec<&str>>()[0];
        file_hashes.push(file_hash);
    }

    file_hashes.dedup();

    return file_hashes;
}

pub fn build_tree(hashes: Vec<&str>, sess: &mut Session) -> (SystemDirectory, SystemDirectory) {
    let mut directories = Vec::new();
    let mut files = Vec::new();

    // create nodes for all files and directories
    for hash in hashes {
        let metadata_file_name = format!("{}/{}.metadata", DIR, hash);
        let metadata = read_remote_json_file(sess, &metadata_file_name);

        if metadata.type_ == DOCUMENT {
            let file = File::new(Hash::new(hash.to_string()), metadata);
            files.push(file);
        } else if metadata.type_ == COLLECTION {
            let directory = Directory::new(Hash::new(hash.to_string()), metadata, None, None);
            directories.push(directory);
        } else {
            println!("Unknown type: {}", metadata.type_);
        };
    }

    // manually create root and trash directories
    let mut root_directory = SystemDirectory::new("home".to_string(), None, None);
    let mut trash_directory = SystemDirectory::new("trash".to_string(), None, None);

    // match files with parent directories
    for file in files {
        let parent_name = file.get_parent().unwrap();
        match parent_name.as_str() {
            "" => root_directory.add_file(file),
            "trash" => trash_directory.add_file(file),
            _ => {
                // TODO improve this
                let parent = directories
                    .iter_mut()
                    .find(|d| d.get_hash().to_string() == parent_name.to_string())
                    .unwrap();
                parent.add_file(file);
            }
        }
    }

    // match directories with parent directories
    for directory in directories.clone() {
        let parent_name = directory.get_parent().unwrap();
        match parent_name.as_str() {
            "" => root_directory.add_directory(directory.clone()),
            "trash" => trash_directory.add_directory(directory.clone()),
            _ => {
                // TODO improve this
                let parent = directories
                    .iter_mut()
                    .find(|d| d.get_hash().to_string() == parent_name.to_string())
                    .unwrap();
                parent.add_directory(directory.clone());
            }
        }
    }

    return (root_directory, trash_directory);
}

pub fn print_tree(node: &dyn Node, depth: usize) {
    // Print the current node with indentation based on the depth
    let indent = " ".repeat(depth * 2);

    // if node is a directory, loop through its child directories
    if let Some(directory_node) = node.as_any().downcast_ref::<SystemDirectory>() {
        println!(
            "{}{}{}",
            indent,
            directory_node.get_visible_name().bold().green(),
            "/".bold().green()
        );
        for directory in directory_node.get_directories() {
            print_tree(directory, depth + 1);
        }
        for file in directory_node.get_files() {
            print_tree(file, depth + 1);
        }
    } else if let Some(directory_node) = node.as_any().downcast_ref::<Directory>() {
        println!(
            "{}{}{}",
            indent,
            directory_node.get_visible_name().bold().green(),
            "/".bold().green()
        );
        for directory in directory_node.get_directories() {
            print_tree(directory, depth + 1);
        }
        for file in directory_node.get_files() {
            print_tree(file, depth + 1);
        }
    } else if let Some(file_node) = node.as_any().downcast_ref::<File>() {
        println!(
            "{}{} {}",
            indent,
            file_node.get_last_modified(),
            file_node.get_visible_name().purple()
        );
    }
}
